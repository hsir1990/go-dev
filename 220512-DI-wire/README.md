# Go依赖注入工具wire

## 介绍

Go 语言常用的依赖注入工具有 google/wire、uber-go/dig、facebookgo/inject，我们以 wire 和 dig 作比较，对比一下两个工具的区别。

- dig 通过反射识别依赖关系，wire 是编译前计算依赖关系，Wire 作为代码生成器运行，这意味着注入器无需调用运行时库即可工作。
- dig 只能在代码运行时，才能知道哪个依赖不对，比如构造函数返回类型的是结构体指针，但是其他依赖的是interface，这样的错误只能在运行时发现，而wire可以在编译的时候就发现。
- 由于采用了依赖注入，所以在代码调试时可以注入一些mock 服务或者函数，wire在mock上支持更友好些，dig的话可以通过build tag 来使用mock。 个人比较推荐使用wire，可以在编译时就发现问题，避免了 多次的build和尝试后才解决编译问题

## 官方文档

- wire github：https://github.com/google/wire

## Wire详解

本文基于 `wire v0.5.0` 编写，关于测试代码可在 [DI-wire](https://github.com/mailjobblog/dev_go/tree/master/220512-DI-wire) 下载。

**创建测试驱动服务**

在测试 wire 过程中，可能需要用到一些 DB 服务，请根据 example 的需求，安装需要的服务。

```bash
# 创建mysql容器
docker run -itd -p 3310:3306 -e MYSQL_ROOT_PASSWORD=root --name wire-mysql mysql:5.7

# 创建数据库和表

# 添加测试数据

```

### 安装

```bash
go install github.com/google/wire/cmd/wire@latest
```

### 快速上手

在开始学习 wire 之前，我们先来探讨一些，为什么要学习 wire 依赖注入，如果不用依赖注入我们的代码是什么样的？用了之后是什么样的？依赖注入的好处是什么？带着这些问题去学习 wire 可以让你事半功倍。

### 为什么要使用wire

我们先来看一段代码，分析依赖注入的好处

main.go

```go
package main

import "fmt"

func main() {
	conf := NewConfig()
	db := NewDB(conf) // DB 依赖 Config
	result := db.Find()
	fmt.Println(result)
}
```
server.go

```go
package main

type Config struct {
	DbSource string
}

func NewConfig() *Config {
	return &Config{
		DbSource: "root:root@tcp(127.0.0.1:3306)/test_db",
	}
}

type DB struct {
	table string
}

func NewDB(cfg *Config) *DB {
	return &DB{table:"test_table"}
}

func (db *DB) Find() string {
	return "db info string"
}
```

**调用步骤如下：**

- 首先用 NewConfig 获取 Config 资源
- 然后 NewDB 获取 DB 资源，这里需要注入 Config 的资源
- 所以这里的 NewDB 依赖 NewConfig 

**使用依赖注入后的代码**

wire.go

```go
//go:build wireinject
// +build wireinject

package main

import (
	"github.com/google/wire"
)

// 调用wire.Build方法传入所有的依赖对象以及构建最终对象的函数得到目标对象
func InitApp() (*App, error) {
	wire.Build(NewConfig, NewDB, NewApp)
	return &App{}, nil // 这里返回值没有实际意义，只需符合函数签名即可，生成的 wire_gen.go 会帮你包装该值
}
```

执行 `wire` 命令生成的代码

```go
// Code generated by Wire. DO NOT EDIT.

//go:generate go run github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package main

// Injectors from wire.go:

func InitApp() (*App, error) {
	config := NewConfig()
	db := NewDB(config)
	app := NewApp(db)
	return app, nil
}
```

main.go

```go
package main

import "fmt"

type App struct {
	db *DB
}

func NewApp(db *DB) *App {
	return &App{
		db: db,
	}
}

func main() {
	app,err := InitApp()
	if err != nil {
		return
	}
	result := app.db.Find()
	fmt.Println(result)
}
```

所以我们在这里已经可以大致看到依赖注入的好处，有以下几个方面

- 开发人员可以更加专注于业务本身，而非具体的依赖实现
- 代码简洁，可阅读性更高

### 上手使用







## 参考资料

**wire**

- https://segmentfault.com/a/1190000039185137
- **https://juejin.cn/post/6844903901469097998**
- **https://www.modb.pro/db/231728**
- https://darjun.github.io/2020/03/02/godailylib/wire
- https://www.cnblogs.com/Me1onRind/p/13624487.html


**wire工程化**

- https://github.com/go-kratos/beer-shop