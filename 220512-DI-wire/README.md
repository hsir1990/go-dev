# Go依赖注入工具wire

## 介绍

Go 语言常用的依赖注入工具有 google/wire、uber-go/dig、facebookgo/inject，我们以 wire 和 dig 作比较，对比一下两个工具的区别。

- dig 通过反射识别依赖关系，wire 是编译前计算依赖关系，Wire 作为代码生成器运行，这意味着注入器无需调用运行时库即可工作。
- dig 只能在代码运行时，才能知道哪个依赖不对，比如构造函数返回类型的是结构体指针，但是其他依赖的是interface，这样的错误只能在运行时发现，而wire可以在编译的时候就发现。
- 由于采用了依赖注入，所以在代码调试时可以注入一些mock 服务或者函数，wire在mock上支持更友好些，dig的话可以通过build tag 来使用mock。 个人比较推荐使用wire，可以在编译时就发现问题，避免了 多次的build和尝试后才解决编译问题

## 官方文档

- wire github：https://github.com/google/wire

## Wire详解

本文基于 `wire v0.5.0` 编写，关于测试代码可在 [DI-wire](https://github.com/mailjobblog/dev_go/tree/master/220512-DI-wire) 下载。

**创建测试驱动服务**

在测试 wire 过程中，可能需要用到一些 DB 服务，请根据 example 的需求，安装需要的服务。

```bash
# 创建mysql容器
docker run -itd -p 3310:3306 -e MYSQL_ROOT_PASSWORD=root --name wire-mysql mysql:5.7

# 创建数据库和表

# 添加测试数据

```

### 代码和文档下载



### 安装

```bash
go install github.com/google/wire/cmd/wire@latest
```

### 快速上手

在开始学习 wire 之前，我们先来探讨一些，为什么要学习 wire 依赖注入，如果不用依赖注入我们的代码是什么样的？用了之后是什么样的？依赖注入的好处是什么？带着这些问题去学习 wire 可以让你事半功倍。

### 为什么要使用wire

我们先来看一段代码，分析依赖注入的好处

main.go

```go
package main

import "fmt"

func main() {
	conf := NewConfig()
	db := NewDB(conf) // DB 依赖 Config
	result := db.Find()
	fmt.Println(result)
}
```
server.go

```go
package main

type Config struct {
	DbSource string
}

func NewConfig() *Config {
	return &Config{
		DbSource: "root:root@tcp(127.0.0.1:3306)/test_db",
	}
}

type DB struct {
	table string
}

func NewDB(cfg *Config) *DB {
	return &DB{table:"test_table"}
}

func (db *DB) Find() string {
	return "db info string"
}
```

**调用步骤如下：**

- 首先用 NewConfig 获取 Config 资源
- 然后 NewDB 获取 DB 资源，这里需要注入 Config 的资源
- 所以这里的 NewDB 依赖 NewConfig

**使用依赖注入后的代码**

wire.go

```go
//go:build wireinject
// +build wireinject

package main

import (
	"github.com/google/wire"
)

// 调用wire.Build方法传入所有的依赖对象以及构建最终对象的函数得到目标对象
func InitApp() (*App, error) {
	wire.Build(NewConfig, NewDB, NewApp)
	return &App{}, nil // 这里返回值没有实际意义，只需符合函数签名即可，生成的 wire_gen.go 会帮你包装该值
}
```

执行 `wire` 命令生成的代码

```go
// Code generated by Wire. DO NOT EDIT.

//go:generate go run github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package main

// Injectors from wire.go:

func InitApp() (*App, error) {
	config := NewConfig()
	db := NewDB(config)
	app := NewApp(db)
	return app, nil
}
```

main.go

```go
package main

import "fmt"

type App struct {
	db *DB
}

func NewApp(db *DB) *App {
	return &App{
		db: db,
	}
}

func main() {
	app,err := InitApp()
	if err != nil {
		return
	}
	result := app.db.Find()
	fmt.Println(result)
}
```

所以我们在这里已经可以大致看到依赖注入的好处，有以下几个方面

- 开发人员可以更加专注于业务本身，而非具体的依赖实现
- 代码简洁，可阅读性更高

### 上手使用

在正式开始之前需要介绍一下wire中的两个概念：`Provider`和`Injector`：

- `Provider`：负责创建对象的方法，比如上文中`控制反转示例`的`NewDB`(提供DB对象)和`NewConfig`(提供Config对象)方法。
- `Injector`：负责根据对象的依赖，依次构造依赖对象，最终构造目的对象的方法，比如上文中`控制反转示例`的`InitApp`方法。

在上文中的例子中，NewConfig 和 NewDB 都是 `provider`，wire_gen.go 中的 InitApp 函数是 `injector`，可以看到`injector`通过按依赖顺序调用`provider`来生成我们需要的对象`App`。

**一个完整的例子**

我们现在来做一个比较完整的demo，来进一步学习 wire 中的知识，更好的理解 wire。

demo文件结构如下

```
|--cmd
	|--main.go
	|--wire.go
|--config
	|--app.json
|--internal
	|--config
		|--config.go
	|--db
		|--db.go
```

config/app.go

```json
{
  "database": {
    "dsn": "root:root@tcp(127.0.0.1:3306)/test_db"
  }
}
```

internal/config/config.go

```go
package config

import (
	"encoding/json"
	"github.com/google/wire"
	"os"
)

var Provider = wire.NewSet(New) // 将New方法声明为Provider，表示New方法可以创建一个被别人依赖的对象,也就是Config对象

type Config struct {
	Database database `json:"database"`
}

type database struct {
	Dsn string `json:"dsn"`
}

func New() (*Config, error) {
	fp, err := os.Open("../config/app.json")
	if err != nil {
		return nil, err
	}
	defer fp.Close()
	var cfg Config
	if err := json.NewDecoder(fp).Decode(&cfg); err != nil {
		return nil, err
	}
	return &cfg, nil
}
```

internal/db/db.go

```go
package db

import (
	"database/sql"
	_ "github.com/go-sql-driver/mysql"
	"github.com/google/wire"
	"wire-example/internal/config"
)

var Provider = wire.NewSet(NewDb) // 将New方法声明为Provider，表示New方法可以创建一个被别人依赖的对象

func NewDb(cfg *config.Config) (db *sql.DB, err error) {
	db, err = sql.Open("mysql", cfg.Database.Dsn)
	if err != nil {
		return
	}
	if err = db.Ping(); err != nil {
		return
	}
	return db, nil
}
```

cmd/wire.go

```go
//go:build wireinject
// +build wireinject

package main

import (
	"github.com/google/wire"
	"wire-example/internal/config"
	"wire-example/internal/db"
)

// 调用wire.Build方法传入所有的依赖对象以及构建最终对象的函数得到目标对象
func InitApp() (*App, error) {
	// 写法1（参考Kratos框架写法）
	// panic(wire.Build(config.Provider, db.Provider, NewApp))

	// 写法2（参考wire官方文档写法）
	wire.Build(config.Provider, db.Provider, NewApp)
	return &App{}, nil // 这里返回值没有实际意义，只需符合函数签名即可，生成的 wire_gen.go 会帮你包装该值
}
```

cmd/main.go

```go
package main

import (
	"database/sql"
	"log"
)

type App struct { // 最终需要的对象
	db *sql.DB // db可以自定义命名，*sql.DB 需要和 internal/db/db.go 中 NewDb 方法返回的类型相同
}

func NewApp(db *sql.DB) *App {
	return &App{
		db: db,
	}
}

func main() {
	app, err := InitApp() // 使用 wire 生成的 injector 方法获取app对象
	if err != nil {
		log.Fatal(err)
	}

	// 测试数据库连接
	var version string
	row := app.db.QueryRow("SELECT VERSION()")
	if err := row.Scan(&version); err != nil {
		log.Fatal(err)
	}
	log.Println(version)
}
```

在 wire.go 同级目录，运行以下生成 wire_gen.go 

```cmd
wire
```

生成的 wire_gen.go 文件内容如下：

```go
// Code generated by Wire. DO NOT EDIT.

//go:generate go run github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package main

import (
	"wire-example/internal/config"
	"wire-example/internal/db"
)

// Injectors from wire.go:

// 调用wire.Build方法传入所有的依赖对象以及构建最终对象的函数得到目标对象
func InitApp() (*App, error) {
	configConfig, err := config.New()
	if err != nil {
		return nil, err
	}
	sqlDB, err := db.NewDb(configConfig)
	if err != nil {
		return nil, err
	}
	app := NewApp(sqlDB)
	return app, nil
}
```

#### 注意事项

**编写规范**

上述示例在`wire.go`中定义了`injector`的函数签名，注意要在文件第一行加上

```go
// +build wireinject
...
```

用于告诉编译器无需编译该文件。在`injector`的签名定义函数中，通过调用`wire.Build`方法，指定用于生成依赖的`provider`

+build wireinject 和 package main 之间，建议空一行，否则容易报错。

**wire.go命名规范**

wire.go文件名不是固定的，不过大家习惯叫这个文件名。

**wire生成错误之main.go语法错误**

在使用 wire 命令生成 wire_gen.go 中，如果你修改 wire.go 中的部分内容，例如 injector 的方法名称，参数类型，返回类型 等等，那么在生成的时候 main.go 中或许无法找到 对应的函数 而报错。

所以建议：任何修改 wire.go 操作，建议注释掉 main.go 中的 main 方法内容，然后再使用 wire 生成文件。

**wire.Build**

`wire.Build(config.Provider, db.Provider, NewApp)`通过传入`config`以及`db`对象来创建最终需要的`App`对象

**injector返回定义**

```go
func InitApp() (*App, error) {
	// 写法1（参考Kratos框架写法）
	// panic(wire.Build(config.Provider, db.Provider, NewApp))

	// 写法2（参考wire官方文档写法）
	wire.Build(config.Provider, db.Provider, NewApp)
	return &App{}, nil // 这里返回值没有实际意义，只需符合函数签名即可，生成的 wire_gen.go 会帮你包装该值
}
```



## 参考资料

**wire**

- https://segmentfault.com/a/1190000039185137
- **https://juejin.cn/post/6844903901469097998**
- **https://www.modb.pro/db/231728**
- https://darjun.github.io/2020/03/02/godailylib/wire
- https://www.cnblogs.com/Me1onRind/p/13624487.html

**wire工程化**

- https://github.com/go-kratos/beer-shop