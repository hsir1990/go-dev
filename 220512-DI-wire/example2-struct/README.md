# Wire 结构体绑定

struct 也可以直接当作一个 provider 使用。如果结构体的 provider 仅仅是用作字段赋值，那么可以使用函数 `wire.Struct` 来赋值。

```go
//go:build wireinject
// +build wireinject

package main

import (
	"github.com/google/wire"
)

func InitApp() (*FooMessage, error) {
	// wire.Struct 注入结构体
	wire.Build(ProvideMessage, ProvideBeer, wire.Struct(new(FooMessage), "Msg", "Ber"))
	return &FooMessage{}, nil
}

// 自定义类型
type Message string
type Beer string

// 测试构造结构体
type FooMessage struct {
	Msg Message
	Ber Beer
}

func ProvideMessage() Message {
	return "info"
}

func ProvideBeer() Beer {
	return "xuehua666"
}
```

**代码分析**

- 在这个 demo 中，为了能更加清晰的看到绑定结构体的效果，我去掉了上一个demo中的 Config 和 DB 

- 在 FooMessage 这个结构体中，由于 Msg、Ber 都是 string 类型，所以导致 wire 无法区分具体的 string，所以这里我们采用自定义string类型，这个自定义我们后面再 wire_gen.go 看到一个比较直观的代码。

- 对于结构体字段绑定的值，我们需要写单独的方法给值，例如本文中的 ProvideMessage、ProvideBeer，并且要写入 wire.Build 完成绑定。

- 主要在构造体绑定上，如果要导入全部的字段，请使用 *

**生成的wire_gen.go如下**

```go
// Code generated by Wire. DO NOT EDIT.

//go:generate go run github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package main

// Injectors from wire.go:

func InitApp() (*FooMessage, error) {
	message := ProvideMessage()
	beer := ProvideBeer()
	fooMessage := &FooMessage{
		Msg: message,
		Ber: beer,
	}
	return fooMessage, nil
}

// wire.go:

type Message string

type Beer string

type FooMessage struct {
	Msg Message
	Ber Beer
}

func ProvideMessage() Message {
	return "info"
}

func ProvideBeer() Beer {
	return "xuehua666"
}
```

在生成的文件中，我们在 InitApp 中可以清晰的看到 message、beer。所以看到这样的定义，我想可以更好的理解为什么两个 string 的时候要使用自定义 string